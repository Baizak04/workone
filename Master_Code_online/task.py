# 1)
a_list = [1, '1', 0, None, False]
result = list(filter(None, a_list))
print(result)
# Если вместо функции для фильтрации (обычно это лямбда) передаеть None, то фильтр оставит в списке только элементы, возвращающие True при проверке истинности. Аналог (item for item in iterable if item)

# 2)
print(print())
# Любая фукция в python по умолчанию возвращает None. Внутренняя функция распечатает пустую строку, так как не имеет аргументов внешняя функция распечатает результат работы внутренней, то есть None

# 3)
a_dict = {}
a_dict[1] = 'foo'
a_dict[True] = 'bar'
print(a_dict)
# В Python булин являются неследниками целых чисел и 1 = True, поэтому при добавлении a_dict[True] = 'bar' просто меняется значение у ключа 1. Верный ответ {1: 'bar'}.

# 4)
# counter = 0

# def increment():
#     counter += 1
    
# increment()
# print(counter)
# При изменении значения переменной внутри функции интерпретатора считает ее локальной и ищет ее обьявление внутри. T.k. Переменная внутри функции не обявлена, упадает исключение.

# 5)
for x in range(3):
    print(x)
    if x == 3:
        break
    else:
        print(10)
# else с циклом for сработает только если цикл не был прерван оператором break, а так х никогда не станет 3, прерывания не будет и распечатает 0 1 2 10.

# 6)
def function():
    try:
        print(1)
        raise ValueError()
    except ValueError:
        print(2)
        return 0
    finally:
        print(3)
        
    
function()
# Несмотря на то, что в блоке except вызван return? интерпретатор не забудет выполнить код из блока finally, так как он должен выполняться  при любом исходе.

# 7)
# a_dict = {(1, 2): 100, (3, 4): 200}
# print([1, 2] in a_dict)
# Ключам словаря могут быть только hashable типы, пна содержание в словаре питон попытается получить хеш искомого объекта. А так как лист не хешируем, то упадет исключение

# 8)
a_set = {1, 2, 3}
a_dict = {3: '3', 4: '4'}
print(a_set - a_dict.keys())
# Ключи словаря поддерживают операции с множествами, и результат аналогичен выражению{1, 2, 3} - {3, 4}, верный ответ {1, 2}.

# 9)
a_list = [1, 2, 3]
print(a_list[1:8])

# 10)
def outer():
    value = 100
    
    def inner():
        global value
        value = 10
    inner()
    print(value)
    
    
outer()
# Функция inner меняет(создает) глобальную переменную, но не value из функции outer, именно внутренняя переменная будет распечатана, верный ответ 100. Если не понятно то читать: LEGB-rule.

# 11)
def outer(a_list):
    def inner(a_list):
        a_list.append(10)
        return a_list
    
    return a_list


print(outer([]))
# Несмотря на то, что функция inner должна добавить в список 10, она не была вызвана, и список вернется неизменным

# 12)
# a_dict = {}
# first_tuple = (1, 2)
# second_tuple = (3, [1, 2])
# a_dict[first_tuple] = 1
# a_dict[second_tuple] = 2
# print(a_dict)
# Кортеж может быть ключом словаря только если содержит hashable объекты, например целые числа и строки, но на не списки. Исключение упадает на строке 5.

# 13)
# k = [print(i) for i in my_string if i not in "aeiou"]
# print(i) выполняется, если символ не является гласной буквой

# 14)
print(r"\nHello Master Code Online")
# Если перед открывающей кавычкой стоит символ ‘r’ (в любом регистре), то механизм экранирования отключается.

# 15)
x = ['ab', 'cd']
for i in x:
    i.upper()
    
print(x)
# Функция upper() не модифицирует строку на лету, а возвращает новую строку, которая в данном случае нигде не сохраняется.

# 16)
print(round(4.576))
# Функция round() округляет число, округленное до указанной точности после запятой опущен или None, функция вернет ближайшее целое число.

# 17)
examle = 'show world'
print('%s' % examle[4:7])

# 18)
# x = ['ab', 'cd']
# for i in x:
#     x.append(i.upper())
#     print(x) 
# Цикл не завершится, поскольку на каждой итерации в него будут добавляться новые элементы.

# 19)
d = {'join': 40, 'peter': 45}
d = 'join' in d
print(d)
# in можно использовать для проверки наличия ключа в словаре.

# 20)
a = {3, 4, 5}
a.update([1, 2, 3])
print(a)

# 21)
i = 0
while i < 3:
    print(i)
    i += 1
else:
    print(0)
# Блок else выполняется, когда условие в while становится ложным

# 22)
print(0xA + 0xB + 0xC)

# 23)
list1 = [1, 3, 2]
list1 *= 2
print(list1)

# 24)
# x = 'abcdef'
# while i in 'x':
#     print(i, end=" ")
# Код выдаст ошибку (NameError: name ‘i’ is not defined)

# 25)
# examle = 'snow world'
# examle[3] = 's'
# print(examle)
# Строки нельзя модифицировать 